安bGNU包
  %gnuzip foo-1.0.tar.gz
  %tar xf foo-1.0.tar
  1. 查看foo-1.0目中的'README',看是否有其它的事情需要做.
  2. 配置源a.F在可以用autoconf砩成'configure'文件.
    % ./configure
  3. g源a
    % cd foo-1.0
    % make
  4. 如果利,安b
    % su
    # make install

  makeψ约H所做的工作并不知道,它x取makefile文件中的指令,并通^shell绦.在安b
  者的角度砜,makefile定x了一目思.

  configure程序是一shell_本,用硖y整系y,然后探yY果根'Makefile.in'砩成
  Makefile. F在'configure'_本可以通^GNU的Autoconf硗瓿,通^入'configure.in',
  可以生成相的configure文件.

  你也不必手'Makefile.in'文件,可以使用GNU的Automake砩成它,通^'Makefile.am'
  文件.在@些文件中,你描述了你的源a要生成的一些文件,然后Automake生成makefile用砭
  g、安b以及卸d.

Makefile
  GNUa手忻枋隽怂有GNU程序所要_到的一些.Makefile适瞧渲械囊徊糠.
  clean:
    有3N型的clean操作： clean, distclean和maintainer-clean
    clean: 清除所有由make以及make check生成的文件,但是不清除由configure生成的文件.
    
    distclean: 清除所有由make以及make check生成的文件,同r也清除由configure生成的文
    件.如果你不再次configure,那么你⒉荒苷{用任何make例程.此r源a浠偷降谝淮谓
    r的B.
    
    maintainer-clean: 清除所有distclean可以清除的文件,同r也清除_l者automake生成
    的文件.由于用舨⒉恍枰GNUg系y戆惭b件包,所以@些文件必得清除.有rSo者也
    需要清除@些文件并重新生成.

    另一N清除就是擦除安b目中的安b包:
      % make uninstall
    
    How to remembering?
    If configure or make did it, make distclean undoes it.
    If make did it, make clean undoes it.
    if make install did it, make uninstall undoes it.
    If you did it, make maintainer-clean undoes it.

    GNU的makefile有一目宋募,即tags,它是一些文件,Emacs用@些文件可以高效的g[
    源a.通^以下命令砩成tag文件:
      % make tags
    你不是源a的作者r,tagsτ谀懔私庠创a非常有椭

    榘l布你更改后的件(意 make distribution)：
      % make dist
    它重新gfoo-1.0.tar.gz,如果你υ创a做了更改,那么@些修改⒈话含M(此r你可
    能需要修改版本).在⑿掳姹景l布到FTP之前,可以先y其完整性:
      % make distcheck
    它⑿掳姹窘旱揭Rr目中,并Lconfigure, build,\行y用例,并y安b_
    本是否能正_工作.如果一切正常,那么你⒈桓嬷你的新版本可以l布了.

Configurationx
	Executables   ==> /usr/local/bin
	Libraries     ==> /usr/local/lib
	Header files  ==> /usr/local/include
	Man pages     ==> /usr/local/man/man?
	Info files    ==> /usr/local/info

  '/usr/local'Qprefix,默J的前Y'/usr/local',但是可以在configure文件中通^
  '--prefix'碓O置,例如,如果你不是超用,那么你⒉荒茉'/usr/local'中安b任何|西,
  此r你可以④件安b在'/home/username'中:
    % ./configure --prefix=/home/username
    % make
    % make check
    % make install
  
  如果你在一个文件系统上安装了软件包,并且想在多个机器(运行GNU或者UNIX)上共享,那么你需要
  安装一些不依赖于系统的文件到一个共享目录中.头文件和文档是可以共享的,但是libraries和
  executables就必须分别安装,解决方案如下:
    Executables   ==> /usr/local/system/bin
    Libraries     ==> /usr/local/system/lib
    Header files  ==> /usr/local/include
    Man pages     ==> /usr/local/man/mann
    Info files    ==> /usr/local/info

  '/var/local/system'叫做executable prefix,通常它是prefix的子目录.如果不指定
  executable prefix,那么会默认为prefix目录.为改变这一状况,使用
    --exec-prefix
  标志来指定相关目录.例如,为GNU/Linux系统的configure为:
    % configure --exec-prefix=/usr/local/linux
  为GNU/Hurd的configure为:
    % configure --exec-prefix=/usr/local/hurd

  通常,一个软件包可能想要安装在很多不同的目录.有些目录是通过prefix来控制的,但是有些
  是通过executable prefix来控制,参见【Installation standard directories】.

  有些安装包允许你启用或禁用某些功能,这些标志为:
    --with-package --enable-feature
    --without-package --disable-feature
  --enable标记通常用来启用软件包的某些功能,比如语言国际化,调试功能以及共享库等特性通常
  都由这些选项来控制.--with标志则控制安装过程是否包含安装包中的可选组建或包.特定软件的标
  记会在README中加以说明.

  configure脚本还可以传递环境变量进去.例如,在configure中可以决定用哪种编译器以及传递哪	
  个标记等等,你可以推翻configure中的设定,比如通过CC标记和CFLAGS标记.例如假定你想编译一
  个最优化的软件包并且不带有任何调试信息(bad idea, yet people want to do it):
    % export CFLAGS="-O3"
    % ./configure

  为告诉configure使用系统自带的编译器(而不是gcc),并且编译一个未优化的调试版本:
    % export CC="cc"
    % export CFLAGS="-g"
    % ./configure

  这里假定你使用的是bash,并且是默认的shell.如果使用csh或tcsh,需要setenv对环境变量赋
  值:
    % setenv CFLAGS "-O3"
    % ./configure

  CXX, CXXFLAGS控制着C++编译器
  
Doing a VPATH build
在一vpathg中,源a存υ谝(可能)只x的目中,而H的gt在一不同的目中,并(在目中)存λ有生成的文件.第一目我Q之source tree,第二Q之build tree,而后者可能是前者的子目,但最好⑺分x在不同的目中.

如果_l者采用了GNUg系y的使δ,那么你不必心vpathg的支持.但如果自己定xmaket,那么就需要做相的D硎沟vpath正_工作.

大部分的UNIX makeM建不支持vpathg,GNUt使得它相具有移植性,如果vpathδ碚f比^重要,那么]有理由不安b它.

假定'/source/foo-0.1'包含一源a包,而你想在目'/build/foo-0.1'中g它.假定2目都存在,你所要做的事情就是:
	% cd /build/foo-0.1
	% /source/foo-0.1/configure …options…
	% make
	% make check
	% su
	% make install
接下淼氖虑榫土艚oconfigure_本以及生成的makefiles硖理.

很多人偏vpathg的理由如下:
阻止g^程_y源a,o其添加各Ng文件(在MS系列的g器中,添加很多生成文件在源a渲).
移除gr,所要做的工作HH是g目.
可以在不同的目中多次g同一源a.τ谟卸configure版本(不同功能,不同g化等等)的件包,可以g多版本磉\行y用例.
通常,如果一源a包是用vpath砭g的,那么它也是被正常g出淼,但反^t不然,@也是楹我用distcheck targetz查完整性的原因,它z查你的l布是否被正_的vpathg^.

Making a binary distribution
在g之后,安b之前,你可以ι成的文件做一些快照(snapshot)并⑵浯虬起:
建一二M制包:
	# make install DESTDIR=/tmp/dist
	# tar CC /tmp/dist Ccvf package-version.tar
	# gzip -9 package-version.tar
DESTDIR指定了一目.

Programming with many source files
目宋募'*.o'包含了量以及子例程的定x(以R的形式).@些定x中的大部分最K⒈磺度氲阶罱K的可绦形募的特定地址中.在未接之前,@些却娴刂肥俏粗的,所以它以符(symbolically)的形式硪用,@些符的引用Q作symbols.可以通^'nm'命令砹谐瞿宋募中定x的符,例如:
	% nm xmalloc.o
				 U error
				 U malloc
				 U realloc
		00000000 D xalloc_exit_failure
		00000000 t xalloc_fail
		00000004 D xalloc_fail_func
		00000014 R xalloc_msg_memory_exhausted
		00000030 T xmalloc
		00000060 T xrealloc
第一列是符在目宋募中的地址(如果符在目宋募中_定x了),第二列是量的型,第三列是量名.
‘T' C 函刀x
‘t' C 私有(private)函刀x,在C中static明的函.
‘D' C 全局量
‘R' C 只x全局量(const)
‘U' C 在目宋募中使用但并未在其中定x的符
更多信息,⒁Binutils manual

During the process of linking, all the machine language instructions that refer to a specific memory address need to be modified to use the correct addresses within the executable, as oppposed to the addresses within their object file. This becomes an issue when you want to your program to load and link compiled object files during run-time instead of compile-time. To make such dynamic linking possible, your symbols need to be relocatable. This means that your symbols definitions must be correct no matter where you place them in memory. There should be no memory addresses that need to be modified. One way to do this is by refering to memory addresses within the object file by giving an offset from the refering address. Memory addresses outside the object file must be treated as interlibrary dependencies and you must tell the compiler what you expect them to be when you attempt to build relocatable machine code. Unfortunately some flavours of Unix do not handle interlibrary dependencies correctly. Fortunately, all of this mess can be dealt with in a uniform way, to the extent that this is possible, by using GNU Libtool. See section Using Libtool, for more details.

g煳募
在很多情r下,一卧中的目宋募可能被多可绦形募使用.在Unix系y和GNU中,可以搜集@些目宋募形成一libraray.在GNU系y中,用'ar'命令建一煳募:
	ar cru libfoo.a foo1.o foo2.o foo3.o

命令用目宋募foo1.o foo2.o foo3.o砩成一libfoo.a文件.在使用libfoo.a之前,需要另一程序z查@煳募:
	% ranlib libfoo.a

在GNU以及大部分Unix系y中,你需要做@工作,即\行'ranlib',但在有些Unix系y上s不是必的,甚至在SGI的Irix系y上,焊就]有@命令.

之所以{@是因v史原因.ar命令最原始的功能HH只是⑽募打包在一起.tar命令是由ar命令派生而,用⑦@些打包的文件存放到磁гO渖.F如今,tar命令就用砀ar原淼墓ぷ,有些人甚至想用tar泶虬*.o文件.但是B接器需要一符表鬟f@些存n文件,所以ranlib就用砩成@符表并⑵涮砑拥*.a文件中.

library安b到系y中,先得⑽募'libfoo.a'放到一誓夸中.H的@目跟你的系y相P.GNUg器在'/usr/lib'和'usr/local/lib'中查找安b目.因楹芏Unix系y也使用GNU的g器,所以@些目在Unix系y中是拾惭b目.但是有些Unixg器并不默J在'usr/local/lib'中查找.一旦安b了一library,斓淖永程就能槎工程(于前目)所用,以用砭g一可绦形募.可以用'-l'酥碜g器指向一彀惭b目,以⒍可绦形募g成一可绦形募:
	% gcc Co foo bar.o Clfoo

要注意的是,如果煳募名'libfoo.a',那么相的'-l'实稻椭荒苁亲幼址串'boo',所以上例中'-lfoo'.煳募必以'lob*.a'的形式砻名.如果你已'libfoo.a'安b到了一非誓夸,你可以用'-L'擞告V接器到目中聿檎以煳募.例如,如果煳募安b在'/home/lf/lib'中:
	% gcc Co bar.o CL/home/lf/lib Clfoo

‘-L'擞必在'-l'擞之前.

Some people like to pass `-L.' to the compiler so they can link uninstalled libraries in the current working directory using the `-l' flag instead of typing in their full filenames. 	The idea is that they think "it looks better" that way. Actually this is considered bad style. You should use the `-l' flag to link only libraries that have already been installed and use the full pathnames to link in uninstalled libraries. The reason why this is important is because, even though it makes no difference when dealing with ordinary libraries, it makes a lot of difference when you are working with shared libraries. (FIXME: Crossreference). It makes a difference whether or not you are linking to an uninstalled or installed shared library, and in that case the `-l' semantics mean that you are linking an installed shared library. Please stick to this rule, even if you are not using shared libraries, to make it possible to switch to using shared libraries without too much hassle.

Also, if you are linking in more than one library, please pay attention to the order with which you link your libraries. When the linker links a library, it does not embed into the executable code the entire library, but only the symbols that are needed from the library. In order for the linker to know what symbols are really needed from any given library, it must have already parsed all the other libraries and object files that depend on that library! This implies that you first link your object files, then you link the higher-level libraries, then the lower-level libraries. If you are the author of the libraries, you must write your libraries in such a manner, that the dependency graph of your libraries is a tree. If two libraries depend on each other bidirectionally, then you may have trouble linking them in. This suggests that they should be one library instead!

Dealing with header file
一般碚f,一library有2N型的^文件：public和private.前者明了一些你需要钠渌件中@取的Y源,後者所明的Y源就是library自身打造的(也就是#include <> 和#include “”的^e…).要使用一安b好的,需要安b其公有的^文件.实念^文件安b目'/usr/include'.GNUg器也可以Re'/usr/local/include'.g器遇到以下指令:
	#include <foo.h>

g器在誓夸中查找'foo.h',如果你㈩^文件安b在【非誓夸】中,可以通^'-I'苏I告Vg器具w的查找目.例如,若要脑始文件'bar.c'g一'bar'程式,原始文件中包含了安在在'/home/username'中的library:
	% gcc Cc CI/home/lf/include bar.c
	% gcc Co bar bar.o CL/home/lf/lib Clfoo

也可以一步完成:
	% gcc CI/home/lf/include Co bar bar.o CL/home/lf/lib Clfoo

橐浦残钥],最好'-I'置于要g的源文件之前.

Makefile相P
格式:
	TARGET: DEPENDENCIES
	TAB COMMAND
	TAB ……
	TAB ……
	[BLANK LINE]

TAB是制性(mandatory)的,最后的空行最好保留,以兼容Unix(在GNU make可去掉).

target可以是生成的文件名,也可以是一个可执行的动作名(action name).
dependency为一个文件,作为输入文件,创建一个target,如果一个targe有多个依赖文件, 那么必须以空格分开,同时也得保证它们位于同一行.target有可能没有依赖文件,那么此 时':'后面的空格必须为空(即':'后不能有空格...Makefile的语法真变态_Orz).
Target后面的commands全面必须以TAB开头,如果target为一个文件,那么该命令即解释如何来创建该文件,如果target为一个action,那么command则描述这个action.这些command都是一些常用的shell命令.

调用'make'时,必须告诉它你想要编译的target,若不指定,则'make'会编译在makefile中出现的第一个目标文件.

我们所提及的用'make'命令来编译一个target,即希望'make'做以下这些事情:
编译dependencies.如果一个dependencies为一个你自己创建的文件(file),那么这意味着什么也不干.如果一个dependency为一个makefile中定义的目标,那么将编译该target.循环进行这2个步骤.
如果任何一个dependency比target'新',或者target这个文件根本不存在,那么command将创建该文件,如果target为一个action,那么command不会创建任何文件,但会执行该action.
如果target是一个文件，并且当前没有更'新'的dependency存在，那么'make'将什么都不干，但会打印一个消息说【无事可干】。如果target为一个action，且没有文件的名称会跟target的名称(即action名称)相同，那么当你每次调用make时，它将老实的执行你的每次调用.

Makefile中的变量定义,如同宏定义一样(那种语言的宏定义?)
	variable = value
这样，在其它规则的定义中，就可以用符号$(variable)来代替value

一个抽象规则定义了如何从文件*.s1编译出*.s2。抽象规则通常的语法是:
	.s1 .s2:
	TAB COMMAND
	TAB COMMAND
	TAV …

此处的s1为源文件的后缀，s2为相应的生成文件的后缀。COMMAND为生成规则。注意，此处没有提及dependency，因为一般情况下dependency是无意义的，它们必须由每个单独的case分别显式提供。

在一个抽象规则的上下文中，下面的这些符号分别有各自的含义:
	'$<' - 这些dependency的改变将会导致target的重编译
	'$@' - 即target
	'$^' - 当前文件的所有dependency

例如，从源文件构造一个目标文件的抽象规则为:
	.c.o:
		gcc -c $<
同样，从一堆目标文件构造可执行文件的规则为:
	.o:
		gcc $^ -o $@

注意，由于可执行文件没有后缀，我们此处只写出目标文件的后缀。当只有一个前缀出现时，就假定为该后缀为s1，而s2则为空字符串。

抽象规则中的后缀需要以这样的方式来组织:
	.SUFFIXES: s1 s2 … sn

makefile并不懂C源码，故不能决定源码文件之间的依赖性。GNU C编译器有这个功能。如果你用'-MM'标致的话，那么编译器会计算并输出相应的依赖关系，例如:
	% gcc -MM foo1.c
	foo1.o: foo1.c gleep2.h gleep3.h
	% gcc -MM foo2.c
	foo2.o: foo2.c gleep1.h
	% gcc -MM foo3.c
	foo3.o: foo3.c gleep1.h gleep2.h
	% gcc -MM foo4.c
	foo4.o: foo4.c gleep3.h
生成的这些依赖关系可以直接用在makefile的依赖列表中.在UNIX系统中需要安装GNU编译器才有这项功能.
处理dependency是编写makefile的障碍之一，另一个障碍就是，即便将这些dependency加入到到了Makefile的变量中，这些变量也需要人为的调整，而让软件安装着来编辑'Makefile'似乎有点不近人情。开发者让用户来编辑'Makefile'基本上让他们无法接受。另一个烦人的地方是clean和install规则的编写(以及这些target的处理)。长远来看，每次编写一个Makefile是相当乏味的。但这些target又是任务的关键所在，保证这些东西的编写没有错误是相当重要的。最后，如果你的lib和程序在多个目录中，那么你的makefile必须能在子目录中递归的调用'make'，也即你要写一大堆的makefile。
这些问题并不是无法解决的，但是需要你有丰富的makefile编写经验。大多数开发者宁可调试源码，也不愿碰这些东西。GNU编译系统可以帮助你设置你的源码。GNU开发者只需要编写以下的'Makefile.am'文件:
	bin_PROGRAM = foo
	foo_SOURCES = foo1.c foo2.c foo3.c foo4.c
再设置一些其它的东西。该文件将被编译成一个之间文件，即'makefile.in', 通过Automake，在安装期间，文件'Makefile'从'Makefile.in'中通过脚本'configure'生成.该shell脚本由开发者提供，也是由Autoconf生成的。

通常情况下你不需要手写Makefile，但是理解makefile是如何工作以及如何编写抽象规则是非常有用的。























