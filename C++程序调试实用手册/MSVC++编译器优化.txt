调度指令:
在Intel奔腾处理器上，可以利用其固有硬件能力，同时执行2条指令，并且2条指令各自在其自己的管线上。...但当2条指令之间有相应的关系，就会产生一种称为管线延迟的情况。通过使用指令排序，编译器将得到指示，重新安排机器代码指令顺序，避免这种相关现象。下面是一个不可避免的管线延迟：
  add  ax, shortInteger;  语句1
  mov  bx, ax          ;  语句2
  sub  dx, dx          ;  语句3
如果处理器同时处理语句1和语句2，则会导致不可预料的结果，因为ax并不存在一个shortInteger拷贝，另外语句3的执行既独立于语句1也独立于语句2。将上面的语句重排列，即可消除：
  add  ax, shortInteger
  sub  dx, dx
  mov  bx, ax
调度指令只能在奔腾级别的微处理器上使用，并且语句重排并不会影响代码的大小。
-------------
函数级连接
优化一个函数是可能的，比如内联函数或当编译器识别到其可以以函数本身从不被调用的方式编译该程序时是可能的。然而函数本身必须被编译，并且包含在目标文件中。但编译器并没有识别其他模块是否访问该函数的方法，只有linker可以识别何时一个函数从来不被激活。
函数级连接保证了一个源模块中的所有函数均以COFF、通过COMDAT记录编码为目标代码。这种信息允许linker识别非激活函数，以将其从可执行文件中删除。若没有COMDAT记录，该过程是不可能的。
-----------
字符串池
识别所有重复的字符串定义。此时编译器只是简单地替代引用地址为该字符串的唯一版本。
-----------
register
可以减少代码长度并改进运行性能，register变量与局部变量类似，仅仅在内存有效――也即仅仅在一个函数中有效。它为相关变量指定寄存器存储，而不是执行堆栈分配。这节约了堆栈空间，并且保证以最快的速度来访问变量，这在代码长度方面也有一些减少。MS VS++编译器并不能识别register关键字，编译器会自动审查每一个内部变量和外部变量的使用方法，巧妙地在寄存器和内存之间处理数据。几乎所有的数据对象都可以使用寄存器存储器，包括常量值、结构成员、函数参数以及由引用传递的参数指针。
一条技术说明：若使用其它C++编译器，那要注意使用地址操作符&来书写寄存器变量：
  void somefunc(void)
  {
    register int iregValue;
    int *piregValue;
    piregValue = &iregValue;
    ...
  }
编译器并不认可用户的寄存器变量请求，相反当全局寄存器分配优化(/Oe选项)打开时，编译器自己选择寄存器。然而，所有与register关联的其他语义都得到兑现。ASCII C不允许使用寄存器对象的地址；但这限制并不适于C++。然而，若将地址操作符应用于一个对象，则编译器必须将该对象放置到一个地址可以表示的位置――实际上这意味着要放置到内存而不是寄存器。
-------------
堆栈检查
Windows如何添加内存到堆中？Windows以页形式在堆栈上分配空间，页的大小与计算机的体系结构有关。对于Intel处理器，每页大小为4K。分配这种附加空间的事件在某次存取落入堆栈的末端之外，进入一个称为保护页(guard page)的区域时发生。保护页是分配给堆栈的最后页，当应用程序到达该页时，Windows提交另一个页以增加堆栈大小，这成为堆栈增长(growing)。
当程序所需要的堆栈空间大于可以从保护页上所获得的空间时，程序将试图渗透到保留内存中，如下所示：
  void func(void) {
    char array[2 * 4096];  /* allocate 2 pages or 8Kb */
    array[8000] = 'a';
  }
问题并不会立即出现，编译器为自动数据分配空间是通过所需求的8K递减处理的，通过ESP执行，但这并不会引起Windows分配更多的堆栈空间。如果为数组分配的空间开始接近于堆栈底部，存取一个接近于该序列末端的元素可能使得堆栈的保护页到达保留内存区。此时Windows将使用非法存取错误结束应用程序，并引起用户注意。
当打开堆栈检查时，C++编译器将计算每一个函数的局部变量的总大小。当一个错误的定义产生一个可能延伸到保护页的对象时，编译器产生一个C运行时库的堆栈检查过程调用。这个C函数只是简单地以4096字节的增量存取堆栈的连续页。
虽然堆栈检查可以建立一个更加可靠的应用层序，但其增加了程序开销，并不必要地降低了运行效率。
上面触发存取错误的语句为：
  array[8000] = 'a';
而不是
  char array[2 * 4096];
记住，只有在代码语句引起实际内存存取时，存取错误才会发生。然而如果子程序在4096字节增量之内顺序访问数组元素，则该程序将正确执行，如下所示：
  array[4096] = 'a';  /* page one access */
  array[5100] = 'b';  /* page two access */

-----------------
覆盖堆栈
为使得该优化有效,应用程序必须使用短期的内部或局部变量.关闭这一优化后,所有的内部变量都有一个唯一的地址空间,而Windows的反应则是悄悄地增加其堆栈_这是一个很耗时的操作.当覆盖堆栈优化打开时,编译器将重用堆栈空间,用来保存那些活动未覆盖的内部变量.这将降低程序运行时堆栈超限的可能.
使用该堆栈优化,程序可以获得双倍的性能提高,同时也最小化了堆栈中局部变量与堆栈顶部的距离.
